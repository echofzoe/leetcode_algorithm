## JVM 运行时内存

### 方法区

- 在`JVM`规范中，方法区是线程共享的运行时内存区域，是堆的逻辑组成部分：
  - 虽然方法区是堆的逻辑组成部分，但是虚拟机可以选择不在方法区实现`GC`，因为这样做效率很低
- 方法区的`GC`主要是针对废弃变量和无用的类：
  - 废弃常量的回收与回收堆中的对象非常类似，如果一个字符串`"aaa"`已经进入了常量池中，但是当前没有任何一个`String`叫做`"aaa"`的，也没有其他地方引用了这个字面量，如果在这个时候发生`GC`，而且必要的话，就会将常量`"aaa"`移除常量池，常量池中的其他类、接口、方法、字段的符号引用也与此类似
  - 判定一个常量是否是`废弃常量`比较简单，而要判定一个类是否是`无用的类`的条件则相对苛刻许多。类需要同时满足下面 3 个条件才能算是`无用的类`
    - 该类所有的实例都已经被回收，也就是`Java`堆中不存在该类的任何实例
    - 加载该类的`ClassLoader`已经被回收
    - 该类对应的`java.lang.Class`对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法
- 不同的`JVM`厂商，对于方法区有着不同的实现方式：
  - `HotSpot`将虚拟机堆内存划分为新生代和老年代，对堆内存进行分代管理，将堆的另一块空间划分成为永久代，用作方法区

### 字符串常量池

- 在不同的`JDK`版本中，方法区中存储的数据是不一样的：
  - 在`JDK1.6`及以前，运行时常量池是方法区的一部分，方法区中存储了类的元信息、静态变量、JIT 编译后的代码（比如`Spring`使用`IOC`或`AOP`创建的`Bean`，或者以`cglib`、反射等形式动态生成的`class`信息）等
- 在`JDK1.7`及以后，`JVM`将运行时常量池从方法区中移了出来，在堆中开辟了一块内存存放常量池

### 永久代

- 方法区和永久代的关系很像 Java 中接口和类的关系，类实现了接口，而永久代就是`HotSpot`虚拟机对虚拟机规范中方法区的一种实现方式：
  - `HotSpot`中，堆 = 年轻代 + 老年代，不包括永久代（方法区）

### 元空间

- 元空间并不是方法区，方法区包括类的元信息、常量池、类变量（静态变量）、静态方法的引用等
  - 在`HotSpot`中：
    - `JDK1.7`之前方法区的实现就是永久代
    - `JDK1.7`把常量池和静态变量放入了堆中，也就是说方法区由永久代（类信息）和堆（常量池、静态变量）实现
    - `JDK1.8`删除了永久代，引入了元空间，也就是说方法区由元空间（类信息）和堆（常量池、静态变量）实现
- `HotSpot`虚拟机在`JDK1.8`后已经取消了永久代，改为元空间，类的元信息被存储在元空间中
- 元空间没有使用堆内存，而是转而使用与堆不相连的本地内存区域。所以，理论上系统可以使用的内存有多大，元空间就有多大，所以不会出现永久代存在时的内存溢出问题
  - 这项改造也是有必要的，永久代的调优是很困难的，虽然可以设置永久代的大小，但是很难确定一个合适的大小，因为其中的影响因素很多，比如类数量的多少、常量数量的多少等
  - 永久代中的元数据的位置也会随着一次`Full GC`发生移动，比较消耗虚拟机性能。同时，`HotSpot`虚拟机的每种类型的垃圾回收器都需要特殊处理永久代中的元数据。将元数据从永久代剥离出来，不仅实现了对元空间的无缝管理，还可以简化`Full GC`以及对以后的并发隔离类元数据等方面进行优化

### JVM 的三种常量池

- 字符串常量池（也叫全局字符串池、`String Pool`、`String Literal Pool`）
  - 在`HotSpot`里实现的`String Pool`是一个`StringTable`类，它是一个`Hash`表，默认值长度是`1009`
  - 这个`StringTable`在每个`HotSpot VM`的实例只有一份，被所有的类共享
  - 字符串常量由一个一个字符组成，放在了`StringTable`上
  - 在`JDK1.6`中，`StringTable`的长度是固定的，长度就是`1009`，因此如果放入`String Pool`中的`String`非常多，就会造成`Hash`冲突，导致链表过长，当调用`String.intern()`时会需要到链表上一个一个找，从而导致性能大幅度下降
  - 在`JDK1.7`中，`StringTable`的长度可以通过参数指定`-XX:StringTableSize=66666`
- `class`文件常量池（`Class Constant Pool`）
  - 每个编译后的`class`文件都有一个`class`常量池，`class`文件中除了包含类的接口、方法、字段等描述信息外，还包含着 "常量池"，用于存放编译器生成的各种字面量和符号引用
    - 这里的字面量就是常量的概念，如文本字符串、被声明成`final`的常量值等
- 运行时常量池（`Runtime Constant Pool`）
  - `JVM`在执行某个类的时候，必须经过加载、链接、初始化，而链接又包括验证、准备、解析三个阶段
  - 当类加载到内存中后，`JVM`就会将`class`常量池中的内容存放到运行时常量池中，由此可知，运行时常量池也是每个类都有一个
  - 我的理解是常量池是存在于编译好的字节码文件里的，是静态的。而运行时常量池是在运行时，加载类后，将字节码的静态内容加载到内存，并在需要的时候解析
  - 在解析阶段，会把符号引用替换为直接引用，解析的过程会去查询字符串常量池的`StringTable`，以保证运行时常量池所引用的字符串与字符串常量池中是一致的