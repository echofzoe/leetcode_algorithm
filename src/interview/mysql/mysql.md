## MySQL

### `MySQL`索引

- `MySQL`索引的建立对于`MySQL`的高效运行是很重要的，索引可以大大提高`MySQL`的检索速度
  - 拿汉语字典的目录页（索引）打比方，我们可以按拼音、笔画、偏旁部首等排序的目录（索引）快速查找到需要的字
- 索引分单列索引和组合索引
  - 单列索引，即一个索引只包含单个列，一个表可以有多个单列索引，但这不是组合索引
  - 联合索引，即一个索引包含多个列
- 创建索引时，需要确保该索引是应用在`SQL`查询语句的条件（一般作为`WHERE`子句的条件）
  - 实际上，索引也是一张表，该表保存了主键与索引字段，并指向实体表的记录
- 索引的缺点：
  - 虽然索引大大提高了查询速度，同时却会降低更新表的速度，如对表进行`INSERT、UPDATE、DELETE`
  - 更新表时，`MySQL`不仅要保存数据，还要保存一下索引文件
  - 建立索引会占用磁盘空间的索引文件

### `b+`索引和`hash`索引

- `hash`索引的缺点：
  - `hash`索引的值是无序的，这意味着`hash`索引的值无法进行范围查找，也无法进行排序
    - 无法进行范围查找，也就无法实现类似`like xxx`这样的模糊查询语句
    - 无法进行排序，也就无法实现类似`group by`和`order by`这样的排序和分组语句
  - `hash`索引相同的键可能会发生哈希碰撞，这时根据散列算法的不同，无法快速找到想要的值，可能还需要进行全表扫描，一个一个去比对
- `AVL`树，`b`树和`b+`树：
  - `AVL`树索引的缺点：
    - 数越高，查询路径就越长，查询效率就越慢
    - （致命缺点）查大于某个值的数据时，首先要定位到这个数据，然后回旋，往回查找
  - `b`树（也称作`b-`树）索引：
    - 单节点可以存一个线性表，导致树高比`AVL`树低，查询速度快
    - 阶的概念：
      - `m`阶`b`树：
        - 每个节点至多有`m`个子节点
        - 每个非叶子结点（除根节点）最少有`m/2`个子节点
        - 所有的叶子节点都在同一层
    - 节点内部可以用二分查找，时间复杂度为`O(logN)`
    - 缺点：
      - 也存在数据回旋查找的问题
  - `b+`树索引：
    - 彻底解决了回旋查找的问题
    - 非叶子节点只存储`key`，不存储`value`，叶子节点既存`key`也存`value`，`key`即索引，`value`即数据地址
    - 叶子结点用指针相连形成链表，叶子结点从左到右按索引排序
    - 定位到某一个叶子结点上的数据时，可以依据叶子结点顺序相连的特性很方便的进行范围查找，而不需要回旋

### 索引失效

- 索引失效主要是针对联合索引的情况：
  - 比如一个联合索引是由`(a,b)`两个字段组成的，那么只有`a`字段是有序的，`b`字段只有在`a`字段也相等的情况下才是有序的
  - 联合索引的排序和我们日常编程中常用的排序手段一样，也是先按第一个字段排序，第一个字段相同时再按第二个字段排序，以此内推
- 最佳左前缀法则（举例联合索引是由`(a,b)`两个字段组成）：
  - `a`字段（最左字段）在`b+`树上是有序的，就能定位到`a`节点，在`a`字段相等的情况下，`b`字段也是有序的，就可以通过二分查找法查找到。故遵循最佳左前缀法则的`sql`语句的查询是没有问题的
  - 如果没有利用最佳左前缀法则的`a`去查找`b`，而是单独的去查找`b`，那么这个时候就用不到索引了，因为`b`字段在树上是无序的，就需要进行全盘扫描
  - 案例：
    - `EXPLAIN SELECT * FROM test WHERE a > 1 AND b = 1`，此语句查询`a > 1`情况下`b`的数据，这时`b`的数据是无序的，所以索引会失效；如果改成`WHERE a == 1 AND b = 1`就没有问题了，当`a`确定时，`b`是有序的
    - `EXPLAIN SELECT * FROM test WHERE a LIKE "%1%"`，此案例的模糊查询的条件，如果百分号放在左边、或两边，都是会引起索引失效的，因为没有遵循最佳左前缀法则

### `InnoDB`和`MyIsam`

- 新版本的`MySQL`默认使用`InnoDB`引擎
- 区别：
  - 事务层面，`InnoDB`支持事务，`MyIsam`不支持
  - 外键层面，`InnoDB`支持外键（如果公共关键字在一个关系中是主关键字，那么这个公共关键字被称为另一个关系的外键），`MyIsam`不支持
  - 索引层面，`InnoDB`是聚集索引，`MyIsam`是非聚集索引，`InnoDB`不支持`FULLTEXT`类型的全文索引，`MyIsam`支持
  - 锁粒度层面，`InnoDB`最小的锁粒度是行锁，`MyIsam`最小的锁粒度是表锁
  - 硬盘存储层面：
    - `InnoDB`存储引擎存储数据库数据，一共有两个文件：
      - `.frm`文件：表的定义文件
      - `.idb`文件：数据和索引存储文件。数据以主键进行聚集索引，把真正的数据保存在叶子节点中
    - `MyIsam`在磁盘上存储成三个文件：
      - `.frm`文件：表的定义文件
      - `.MYD`文件：`MYData`，数据文件
      - `.MYI`文件：`MYIndex`文件，索引文件

### 聚集索引和非聚集索引

- 聚集索引（`InnoDB`默认使用）：

  - 将数据和索引放到一个文件里，索引结构的叶子节点保存了行数据

  - 表数据按照索引的顺序来存储，也就是说索引项的顺序与表中记录的物理顺序一致

  - `InnoDB`中，在聚集索引之上建立的索引称为辅助索引，比如复合索引、前缀索引、唯一索引等

  - 聚集索引是一个概念，它默认使用主键索引

    - 如果表中没有定义主键，`InnoDB`会选择一个`唯一的非空索引`来代替
    - 如果表中也没有`唯一的非空索引`，`InnoDB`会在内部生成一个名为`GEN_CLUST_INDEX`的隐式的聚集索引
    - 故，无论怎样，`InnoDB`都有一个唯一的聚集索引

  - 索引结构：

    ![innodb聚簇索引结构](.\static\innodb聚簇索引结构.png)

- 非聚集索引（`MyIsam`默认使用）：

  - 将数据与索引分开存储，表数据的存储顺序与索引顺序无关

  - 索引结构：

    ![myisam非聚簇索引结构](.\static\myisam非聚簇索引结构.png)

- 覆盖索引：`select`的数据列只用从索引中就能够获得，不必读取数据行。换句话说，查询列要被所建的索引覆盖

### 一条`SQL`语句的执行流程

- `SQL`语句可以分为两种，一种是查询，一种是更新（增加，更新，删除）
- 查询语句执行流程：
  1. 先检查该语句是否有权限，如果没有权限，直接返回错误信息；如果有权限，`MySQL`会先查询缓存（以这条`SQL`语句为`key`在内存中查询是否有结果），如果有直接缓存就从缓存中取，如果没有直接缓存就执行下一步
  2. 通过分析器进行词法分析，提取`SQL`语句的关键元素，检查语句是否有语法错误、关键词是否正确等等，如果没有问题就执行下一步
  3. 优化器进行确定执行方案，如果有多种执行方案，优化器根据自己的优化算法进行选择执行效率最好的一个方案（优化器认为好的，不一定是最好的）。确认了执行方案后就准备开始执行了
  4. 进行权限校验，如果没有权限就会返回错误信息，如果有权限就会调用数据库引擎接口，返回引擎的执行结果
- 更新语句执行流程：
  - 执行更新的时候需要记录日志，因为更新操作会对数据库数据产生影响
  - 日志有两种，归档日志`bin log`，以及`InnoDB`特有的`redo log`，正因为如此，`InnoDB`支持事务
  - 流程：权限校验 -> 分析器 -> 执行器 -> `redo log（prepare）` -> `binlog` -> `redo log（commit）`























