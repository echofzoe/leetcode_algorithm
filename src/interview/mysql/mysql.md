## 索引

### `MySQL`索引

- `MySQL`索引的建立对于`MySQL`的高效运行是很重要的，索引可以大大提高`MySQL`的检索速度
  - 拿汉语字典的目录页（索引）打比方，我们可以按拼音、笔画、偏旁部首等排序的目录（索引）快速查找到需要的字
- 索引分单列索引和组合索引
  - 单列索引，即一个索引只包含单个列，一个表可以有多个单列索引，但这不是组合索引
  - 联合索引，即一个索引包含多个列
- 创建索引时，需要确保该索引是应用在`SQL`查询语句的条件（一般作为`WHERE`子句的条件）
  - 实际上，索引也是一张表，该表保存了主键与索引字段，并指向实体表的记录
- 索引的缺点：
  - 虽然索引大大提高了查询速度，同时却会降低更新表的速度，如对表进行`INSERT、UPDATE、DELETE`
  - 更新表时，`MySQL`不仅要保存数据，还要保存一下索引文件
  - 建立索引会占用磁盘空间的索引文件

### `MySQL`有哪些索引

- 从逻辑角度看：
  - 主键索引：一种特殊的唯一索引，不允许有空值
  - 唯一索引、非唯一索引
  - 单列索引（普通索引）
  - 联合索引（多列索引）
- 从数据结构角度看：
  - `B+`树索引
  - `hash`索引
  - `FULLTEXT`索引
- 从物理存储角度看：
  - 聚集索引
  - 非聚集索引

### 覆盖索引

- 前置知识：
  - 主键索引：索引表的叶节点直接保存数据
    - 查询时，指定定位到主键对应的叶子节点就能拿到数据
  - 辅助索引：索引表的叶节点保存主键值
    - 查询时，需要先从辅助索引的索引表查询到主键的值，再使用主键值去主键索引上查询数据，这个过程也称作 **回表**
- 覆盖索引是指`select`的数据列只从辅助索引表中就能获取，而无需回表，可以减少回表时的大量`IO`操作

### `b+`索引和`hash`索引

- `hash`索引：
  - 优点：
    - 查询效率高。索引的检索可以一次到位，不像`B+`树索引需要从根节点寻址到叶节点进行多次`IO`访问
  - 缺点：
    - `hash`索引的值是无序的，这意味着`hash`索引的值无法进行范围查找，也无法进行排序
      - 无法进行范围查找，也就无法实现类似`like xxx`这样的模糊查询语句
      - 无法进行排序，也就无法实现类似`group by`和`order by`这样的排序和分组语句
    - `hash`索引相同的键可能会发生哈希碰撞，这时根据散列算法的不同，无法快速找到想要的值，可能还需要进行全表扫描，一个一个去比对
    - 只有`Memory`存储引擎支持`hash`索引
- `AVL`树，`b`树和`b+`树：
  - `AVL`树索引的缺点：
    - 数越高，查询路径就越长，查询效率就越慢
    - （致命缺点）查大于某个值的数据时，首先要定位到这个数据，然后回旋，往回查找
  - `b`树（也称作`b-`树）索引：
    - 单节点可以存一个线性表，导致树高比`AVL`树低，查询速度快
    - 阶的概念：
      - `m`阶`b`树：
        - 每个节点至多有`m`个子节点
        - 每个非叶子结点（除根节点）最少有`m/2`个子节点
        - 所有的叶子节点都在同一层
    - 节点内部可以用二分查找，时间复杂度为`O(logN)`
    - 缺点：
      - 也存在数据回旋查找的问题
  - `b+`树索引：
    - 彻底解决了回旋查找的问题
    - 非叶子节点只存储`key`，不存储`value`，叶子节点既存`key`也存`value`，`key`即索引，`value`即数据地址
    - 叶子结点用指针相连形成链表，叶子结点从左到右按索引排序
    - 定位到某一个叶子结点上的数据时，可以依据叶子结点顺序相连的特性很方便的进行范围查找，而不需要回旋

### 索引失效

- 索引失效主要是针对联合索引的情况：
  - 比如一个联合索引是由`(a,b)`两个字段组成的，那么只有`a`字段是有序的，`b`字段只有在`a`字段也相等的情况下才是有序的
  - 联合索引的排序和我们日常编程中常用的排序手段一样，也是先按第一个字段排序，第一个字段相同时再按第二个字段排序，以此内推
- 最佳左前缀法则（举例联合索引是由`(a,b)`两个字段组成）：
  - `a`字段（最左字段）在`b+`树上是有序的，就能定位到`a`节点，在`a`字段相等的情况下，`b`字段也是有序的，就可以通过二分查找法查找到。故遵循最佳左前缀法则的`sql`语句的查询是没有问题的
  - 如果没有利用最佳左前缀法则的`a`去查找`b`，而是单独的去查找`b`，那么这个时候就用不到索引了，因为`b`字段在树上是无序的，就需要进行全盘扫描
  - 案例：
    - `EXPLAIN SELECT * FROM test WHERE a > 1 AND b = 1`，此语句查询`a > 1`情况下`b`的数据，这时`b`的数据是无序的，所以索引会失效；如果改成`WHERE a == 1 AND b = 1`就没有问题了，当`a`确定时，`b`是有序的
    - `EXPLAIN SELECT * FROM test WHERE a LIKE "%1%"`，此案例的模糊查询的条件，如果百分号放在左边、或两边，都是会引起索引失效的，因为没有遵循最佳左前缀法则

### `InnoDB`和`MyIsam`

- 新版本的`MySQL`默认使用`InnoDB`引擎
- 区别：
  - 事务层面，`InnoDB`支持事务，`MyIsam`不支持
  - 外键层面，`InnoDB`支持外键（如果公共关键字在一个关系中是主关键字，那么这个公共关键字被称为另一个关系的外键），`MyIsam`不支持
  - 索引层面，`InnoDB`是聚集索引，`MyIsam`是非聚集索引，`InnoDB`不支持`FULLTEXT`类型的全文索引，`MyIsam`支持
  - 锁粒度层面，`InnoDB`最小的锁粒度是行锁，`MyIsam`最小的锁粒度是表锁
  - 硬盘存储层面：
    - `InnoDB`存储引擎存储数据库数据，一共有两个文件：
      - `.frm`文件：表的定义文件
      - `.idb`文件：数据和索引存储文件。数据以主键进行聚集索引，把真正的数据保存在叶子节点中
    - `MyIsam`在磁盘上存储成三个文件：
      - `.frm`文件：表的定义文件
      - `.MYD`文件：`MYData`，数据文件
      - `.MYI`文件：`MYIndex`文件，索引文件

### 聚集索引和非聚集索引

- 聚集索引（`InnoDB`默认使用）：

  - 将数据和索引放到一个文件里，索引结构的叶子节点保存了行数据

  - 表数据按照索引的顺序来存储，也就是说索引项的顺序与表中记录的物理顺序一致

  - `InnoDB`中，在聚集索引之上建立的索引称为辅助索引，比如复合索引、前缀索引、唯一索引等

  - 聚集索引是一个概念，它默认使用主键索引

    - 如果表中没有定义主键，`InnoDB`会选择一个`唯一的非空索引`来代替
    - 如果表中也没有`唯一的非空索引`，`InnoDB`会在内部生成一个名为`GEN_CLUST_INDEX`的隐式的聚集索引
    - 故，无论怎样，`InnoDB`都有一个唯一的聚集索引

  - 索引结构：

    ![innodb聚簇索引结构](..\assets\statics\innodb聚簇索引结构.png)

- 非聚集索引（`MyIsam`默认使用）：

  - 将数据与索引分开存储，表数据的存储顺序与索引顺序无关

  - 索引结构：

    ![myisam非聚簇索引结构](..\assets\statics\myisam非聚簇索引结构.png)

- 覆盖索引：`select`的数据列只用从索引中就能够获得，不必读取数据行。换句话说，查询列要被所建的索引覆盖

### 一条`SQL`语句的执行流程

- `SQL`语句可以分为两种，一种是查询，一种是更新（增加，更新，删除）
- 查询语句执行流程：
  1. 先检查该语句是否有权限，如果没有权限，直接返回错误信息；如果有权限，`MySQL`会先查询缓存（以这条`SQL`语句为`key`在内存中查询是否有结果），如果有直接缓存就从缓存中取，如果没有直接缓存就执行下一步
  2. 通过分析器进行词法分析，提取`SQL`语句的关键元素，检查语句是否有语法错误、关键词是否正确等等，如果没有问题就执行下一步
  3. 优化器进行确定执行方案，如果有多种执行方案，优化器根据自己的优化算法进行选择执行效率最好的一个方案（优化器认为好的，不一定是最好的）。确认了执行方案后就准备开始执行了
  4. 进行权限校验，如果没有权限就会返回错误信息，如果有权限就会调用数据库引擎接口，返回引擎的执行结果
- 更新语句执行流程：
  - 执行更新的时候需要记录日志，因为更新操作会对数据库数据产生影响
  - 日志有两种，归档日志`bin log`，以及`InnoDB`特有的`redo log`，正因为如此，`InnoDB`支持事务
  - 流程：权限校验 -> 分析器 -> 执行器 -> `redo log（prepare）` -> `binlog` -> `redo log（commit）`

### 行锁在有索引和无索引时加锁的区别

- `InnoDB`的行锁锁的是索引
- `InnoDB`只有通过索引来检索数据时，才会加行级锁，否则，将使用表锁（因为没有索引时的检索相当于全局检索）

## 事务

- 事务指访问并可能更新数据库中各种数据项的一个程序执行单元
- 事务是恢复和并发控制的基本单位

### ACID

- 事务应该具有`4`个属性
- `Atomicity`：原子性，一个事务中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节
  - 事务在执行过程中发生错误，会被回滚（`Rollback`）到事务开始前的状态，就像这个事务从来没有执行过一样
- `Consistency`：一致性，在事务开始之前和事务结束以后，数据库的完整性没有被破坏
  - 一致性与原子性密切相关
- `Isolation`：隔离性，一个事务的执行不能被其他事务干扰
  - 一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰
- `Durability`：持久性，一个事务一旦提交，它对数据库所做的更改就应该是永久性的

### 事务隔离级别

- 事务隔离级别主要为了解决并发事务所带来的的一些问题

##### 并发事务带来的问题

1. 脏读：事务1读取了事务2未提交的数据，当事务2进行回滚，事务1之前读取到的数据是不合法的
   - 可能由`select`操作未加锁引起
2. 更新丢失：事务1与事务2同时更新一行数据，事务1的更新操作将事务2的更新操作覆盖了
3. 不可重复读：事务1两次读取同一数据，每次的读取结果不同
   - 事务1两次读取数据期间，事务2对这个数据进行了更新操作并提交，导致事务1两次读取数据的结果不同
   - 可能由`update`操作未加锁引起
4. 幻读（虚读）：事务1两次查询一批数据（比如一个表），第二次查询的结果比第一次多了或少了一些记录
   - 事务1两次查询表期间，事务2对表进行了插入或删除记录的操作并提交，导致事务1两次读查询数据的结果不同
   - 可能由`insert`和`delete`操作未加锁引起

##### 脏读和不可重复读的区别

- 脏读是事务1读取了事务2未提交的脏数据，不可重复读是事务1读取了事务2已提交的数据

##### 不可重复读和幻读的区别

- 不可重复读查询的是同一个数据项，幻读针对的是一批数据整体

##### 事务隔离级别（由低到高）

- `Read uncommitted`读未提交：最低级别，无法解决任何问题
- `Read committed`读已提交：可避免脏读
- `Repeatable read`可重复读：可避免脏读、不可重复读
- `Serializable`串行化：最高级别，能使事务间串行执行，能避免脏读、不可重复读、幻读，但是执行效率最低、性能开销最大

### Propagation - 事务的传播

- `Propagation`：指一个事务方法被另一个事务方法调用时，这个事务方法应该如何进行
- 传播行为，共`6`种，嵌套传播是`Spring`特有的：
  - `PROPAGATION_REQUIRED`：表当前方法必须运行在事务中，如果当前没有事务，就新建一个事务。这是最常见的选择
  - `PROPAGATION_REQUIRES_NEW`：表当前方法必须运行在新建的事务中，如果当前有事务，则将其挂起
  - `PROPAGATION_SUPPORTS`：表当前方法不需要事务上下文，如果当前没有事务，就以非事务方式执行
  - `PROPAGATION_NOT_SUPPORTED`：表当前方法必须不运行在事务中，如果当前有事务，则将其挂起
  - `PROPAGATION_MANDATORY`：表当前方法必须运行在事务中，如果当前没有事务，就抛出异常
  - `PROPAGATION_NEVER`：表当前方法必须不运行在事务中，如果当前有事务，就抛出异常
  - `PROPAGATION_NESTED`：`Spring`特有的。表当前事务必须嵌套在已存在的事务中运行，如果当前没有事务，就采取`PROPAGATION_REQUIRED`的做法

## MVCC

- `Multiversion Concurrent Control`：多版本并发控制

  - 不同存储引擎的`MVCC`不同，典型的有乐观并发控制与悲观并发控制

- `MVCC`可以在并发访问数据库时，对正在事务内处理的数据做多版本管理，以避免写操作堵塞时引发的读操作并发问题

  - `MVCC`是通过保存数据在某个时间点的快照来实现的
  - `MVCC`维持一个数据的多个版本，使得读写操作没有并发冲突

- 锁机制可以控制并发操作，但系统开销较大，`MVCC`能在大多数情况下代替行级锁

- 当前读与快照读：

  - 当前读（悲观`CC`）：读取的是记录的最新版本，读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁
  - 快照读（乐观`CC`）：读取版本快照，即不加锁的非阻塞读
    - 快照读的前提是隔离级别不是串行级别，串行级别下的快照读会退化成当前读
    - 快照读就是`MySQL`实现的`MVCC`理想模型的一个具体的非阻塞读功能

- 底层实现原理：

  - 主要依赖记录中的`3个隐藏字段、undo 日志及 Read View`来实现

    1. `3`个隐藏字段：每行记录除了我们自定义的字段外，还有数据库隐式定义的`DB_TRX_ID, DB_ROLL_PTR, DB_ROW_ID`等字段

       - `DB_TRX_ID`：`6 byte`，表创建该记录或最后一次修改该记录的事务`ID`

       - `DB_ROLL_PTR`：`7 byte`，回滚指针，指向这条记录的上一个版本

       - `DB_ROW_ID`：`6 byte`，隐藏主键的自增`ID`，如果数据表没有主键，`InnoDB`会自动以`DB_ROW_ID`产生一个聚簇索引

    2. `undo`日志：

       - `insert undo log`：事务在`insert`新记录时产生的`undo log`，只在事务回滚时需要，并且在事务提交后可以被立即丢弃

       - `update undo log`：事务在进行`update`或`delete`时产生的`undo log`；不仅在事务回滚时需要，在快照读时也需要，所以不能随便删除

    3. `Read View`读视图：事务进行快照读操作的时候产生的视图

       - 主要用作可见性判断，即当某个事务执行快照读时，以此作为条件判断当前事务读取到的是哪个版本的数据，这个数据可能是最新的数据、也可能是该行记录的`undo log`里的某个版本的数据

## 范式

- 关键字：
  - 主关键字：表中的一个或多个字段，它的值用于唯一标识表中的某一条记录。主关键字又可以称为主键
    - 主键可以由一个字段，也可以由多个字段组成，分别称为单字段主键或多字段主键。并且它可以唯一确定表中的一行数据，或者可以唯一确定一个实体
  - 超关键字：能够唯一确定记录的一个字段或几个字段的组合被称为“超关键字”
    - “超关键字”虽然能唯一确定记录，但是它所包含的字段可能是有多余的
  - 候选关键字：如果一个超关键字去掉其中任何一个字段后不再能唯一地确定记录，则称它为“候选关键字”
- 第一范式（`1NF`）：关系模式`R`的所有属性都不能再分解为更基本的数据单位了
  - 即数据库表中的字段属性都由基本类型构成，比如`int, char, 布尔(tinyint), datetime`
- 第二范式（`2NF`）：关系模式`R`在满足`1NF`的基础上，数据库表中不存在非关键字段对任一候选关键字段的部分函数依赖，也即所有非关键字段都完全依赖于任意一组候选关键字
  - 部分函数依赖指的是存在组合关键字中的某些字段决定非关键字段的情况
- 第三范式（`3NF`）：关系模式`R`在满足`2NF`的基础上，数据表中如果不存在非关键字段对任一候选关键字段的传递函数依赖则符合第三范式





















