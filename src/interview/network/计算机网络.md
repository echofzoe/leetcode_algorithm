## 计算机网络

### 单点登录

- 三种实现方式：
  - `session`广播：也就是`session`复制，将一个微服务模块上已存储登录信息的`session`复制到所有其他分布式模块中，缺点是在集群模块很多时，复制过程将消耗极大的资源
  - `cookie + redis`：
    1. 在集群的任一模块中进行登录，之后，将数据放到两个地方：
       1. `redis`：`key`中存入随机生成的唯一值，`value`中存入用户数据，可以通过设置`redis`的过期时间来做到和`session`一样的效果
       2. `cookie`：把`redis`中生成的`key`存入`cookie`
    2. 访问集群中其他模块时，浏览器发送的请求会携带`cookie`信息
    3. 服务器得到请求后，会获取`cookie`值，并
       - 把`cookie`中获取到的值拿到`redis`中进行查询，通过是否能够查询到数据判断当前是否是登录
  - `token`：
    1. 在集群的任一模块中进行登录，登录后，按照规则生成字符串，再将登录后的用户信息包含到字符串中，进行一些编码加密的工作
    2. 将字符串返回（通过`cookie`或通过地址栏）
    3. 再去访问其他模块时，每次访问都会在地址栏带上生成的字符串，在访问模块中获取地址栏中的字符串，将字符串解码获取里面的用户信息
       - 通过是否能在字符串中获取到用户信息判断当前是否是登录

### `JWT(Json Web Token)`

- `token`是按照一定规则生成的字符串，但是规则是自定义的，而`JWT`是一种通用的规则
- `encode`：比如`asjri4bc82hr.sa1b2dfekjYe9D.qm34rp76it`，由两个`.`划分成了三个部分
  - 第一部分：`JWT`头信息，是一个描述`JWT`元数据的`JSON`对象
  - 第二部分：有效载荷，包含了主体信息（用户信息）
  - 第三部分：签名哈希，对上面两部分数据签名，确保数据不会被更改

### `HTTP`

- `HTTP`是一个无状态的应用层协议，它基于`TCP/IP`来传输数据

- 客户端发送一个`HTTP`请求报文给服务器，服务器会根据请求报文中的信息进行处理，并将处理结果放入`HTTP`响应报文中返回给客户端

  - 客户端请求报文结构

    ![image-20210407170849907](..\assets\statics\客户端请求报文结构.png)

  - 服务器响应报文结构

    ![image-20210407171234523](D:\CODE\JAVA\leetcode_algorithm\src\interview\assets\statics\服务器响应报文结构.png)

- `HTTP`方法：

  - 安全的方法：安全的`HTTP`方法不会改变服务器状态，也就是说它只是可读的
    - `GET: `用于获取资源
    - `HEAD: `用于获取报文首部
    - `OPTIONS: `用于查询当前`URL`支持的方法
  - 不安全的方法：不安全的`HTTP`方法会引起服务器的状态改变
    - `POST: `用于传输实体主体
    - `PUT: `用于上传文件
    - `DELETE: `用于删除文件

- `HTTP`状态码：

  | 状态码 |                类别                |            含义            |
  | :----: | :--------------------------------: | :------------------------: |
  |  1xx   |  `Informational`（信息性状态码）   |    表接收的请求正在处理    |
  |  2xx   |      `Success`（成功状态码）       |      请求正常处理完毕      |
  |  3xx   |   `Redirection`（重定向状态码）    | 需要进行附加操作以完成请求 |
  |  4xx   | `Client Error`（客户端错误状态码） |     服务器无法处理请求     |
  |  5xx   | `Server Error`（服务器错误状态码） |     服务器处理请求出错     |

  - 示例：
    - `100 Continue`：表明到目前为止都很正常，客户端可以继续发送请求或者忽略这个响应
    - `200 OK`
    - `204 No Content`：请求已经成功处理，但是返回的响应报文不包含实体的主体部分。一般在只需要从客户端往服务器发送信息，而不需要返回数据时使用
    - `302 Found`：临时性重定向
    - `400 Bad Request`：请求报文中存在语法错误
    - `403 Forbidden`：请求被拒绝。
    - `404 Not Found`
    - `500 Internal Server Error`：服务器正在执行请求时发生错误
    - `503 Service Unavailable`：服务器暂时处于超负载或正在进行停机维护，现在无法处理请求

### `cookie`与`session`

- `HTTP`协议是无状态的，这种设计主要是为了让`HTTP`协议尽可能的简单，使得它能够处理大量事务

- 在`HTTP/1.1`中，引入了`Cookie`来保存状态信息

- ***`Cookie`：***

  - `Cookie`是服务器发送到浏览器并保存到浏览器本地的一小块数据，它会在浏览器之后向同一服务器再次发起请求时被携带上，用于告知服务器两个请求是否来自同一个浏览器

  - 由于当前浏览器在首次请求之后的每次请求都会携带`Cookie`，因此会带来额外的性能开销

  - 用途：

    - 会话状态管理：如用户登录状态、购物车状态等需要记录的信息
    - 个性化设置：如用户自定义设置、主题设置等
    - 浏览器行为跟踪：用于跟踪分析用户行为

  - 创建过程：

    - 服务器发送的响应报文包含`Set-Cookie`首部字段，客户端得到响应报文后把`Cookie`内容保存到浏览器中

      ```html
      HTTP/1.0 200 OK
      Content-type: text/html
      Set-Cookie: yummy_cookie=choco
      Set-Cookie: tasty_cookie=strawberry
      
      [page content]
      ```

    - 客户端之后对同一个服务器发送请求时，会从浏览器中取出`Cookie`信息并通过`Cookie`请求首部字段发送给服务器

      ```html
      GET /sample_page.html HTTP/1.1
      Host: www.example.org
      Cookie: yummy_cookie=choco; tasty_cookie=strawberry
      ```

- ***`session`：***
  
  - 除了可以将用户信息通过`Cookie`存储在用户浏览器中，也可以利用`Session`存储在服务器端。因此，`Session`更加安全
  - `Session`可以存储在服务器上的文件、数据库或者内存中，也可以将`Session`存储在`Redis`这种内存型数据库中，效率会更高
  - 使用`Session`维护用户登录状态的过程如下：
    - 用户进行登录时，把用户提交的包含用户名和密码的表单，放入`HTTP`请求报文中
    - 服务器验证该用户名和密码，如果正确则把用户信息存储到`Redis`中，它在`Redis`中的`key`称为`Session ID`
    - 服务器返回的响应报文中的`Set-Cookie`首部字段包含了这个`Session ID`，客户端收到响应报文后将该`Cookie`值存入浏览器中
    - 客户端之后对同一个服务器进行请求时会包含该`Cookie`值，服务器收到请求后会在`Cookie`中提取出`Session ID`，再使用`Session ID`去`Redis`中取出用户信息，继续之前的业务操作
  - 当浏览器禁用了`Cookie`时，就只能使用`Session`了。这时也不能再将`Session ID`存放到`Cookie`中，而是要使用`URL`重写技术，将`Session ID`作为`URL`的参数进行传递
  - `Session`的默认过期时间为`30`分钟
  
- ***`Cookie`与`Session`的区别：***

  - `Cookie`只能存储`ASCII`码字符串，而`Session`可以存储任何类型的数据，因此在考虑数据复杂性时首选`Session`
  - `Cookie`存储在浏览器中，容易被恶意查看。如果非要将一些隐私数据存在`Cookie`中，可以将`Cookie`值进行加密，然后在服务器进行解密
  - 对于大型网站来说，如果将用户的所有信息都存储在`Session`中，那么开销是非常大的，因此不建议将所有的用户信息都存储在`Session`中

