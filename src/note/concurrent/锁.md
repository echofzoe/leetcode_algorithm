## 锁

### 不可重入锁和可重入锁

- 不可重入锁，是指同一线程的外层代码已经获得了锁，在内层代码中再次尝试获取琐时，线程就会因获取失败而阻塞，陷入死锁
- 可重入锁也叫递归锁，即允许同一个线程多次获取同一把锁，比如同一线程的外层代码已经获得了锁，在内层代码中再次尝试获取锁时，线程不会阻塞
  - 可重入锁可以通过一个锁中内置的计数器来实现：当前线程尝试再次获取琐时，它首先会通过`count`是否大于`0`来判断当前线程是否持有这把锁，如果`count > 0`，那么就继续将上锁次数`+1`；如果`count = 0` ，那么就说明这把锁没有被持有，当前线程就可以通过`cas`去获取这把锁
  - 当获取锁的线程执行完毕，在释放锁时，需要把`count - 1`

### 乐观锁和悲观锁

- 乐观锁和悲观锁并不是特指某一个锁，而是指在并发情况下的两种不同的策略
- 乐观锁，是指总是乐观的认为每次操作数据的时候，数据都不会被其他线程修改，所以就不会上锁；每次写数据时，就通过`cas`循环尝试写操作
- 悲观锁，是指总是悲观的认为每次操作数据的时候，数据都会被其他线程修改，所以在操作数据时会加锁
- 在`Java`中，只要有锁对象出现，那么一定是悲观锁，因为乐观锁不是锁，它只是一个循环尝试`cas`的算法
  - `synchronized`从偏向锁、轻量级锁到重量级锁都是悲观锁
    - 扩展：为什么网上有些资料认为偏向锁、轻量级锁是乐观锁？理由是它们底层用到了`cas`？
      - 线程在抢占这些锁的时候，执行的确实是循环`cas`的操作，感觉好像是乐观锁。但问题的关键是，我们说一个锁是悲观锁还是乐观锁，总是应该站在应用层，看它们是如何锁住应用数据的，而不是站在底层看抢占锁的过程。如果一个线程尝试获取锁时，发现已经被占用，它是否继续读取数据，等后续要更新时再决定要不要重试？对于偏向锁、轻量级锁来说，显然答案是否定的。无论是挂起还是忙等，对应用数据的读取操作都被"挡住"了。从这个角度看，它们确实是悲观锁
  - `JDK`提供的`Lock`接口的实现类，也都是悲观锁，比如`ReentrantLock`

### 公平锁和非公平锁

- 公平锁：
  - 如果多个线程申请一把公平锁，那么当锁释放的时候，先申请的先得到，非常公平
- 非公平锁：
  - 如果多个线程申请一把非公平锁，后申请的线程可能先获取到锁
- 对于`synchronized`而言，它是一种非公平锁，但是并没有任何办法使其变成公平锁

### 可中断锁

- 可中断锁，即可以相应中断的锁
- `ReentrantLock`是可中断锁，因为
  - `Lock`接口中有一个`lockInterruptibly()`方法，这个方法可以使当前线程拿不到锁就一直等，如果等待时收到中断请求，则需要处理`InterruptedException`
  - `Lock`接口中有一个`tryLock()`方法，我们可以通过此方法的参数自定义等待时间，如果当前线程等待超时就会马上返回

### `synchronized`与`Lock`

- `Java`中有两种加锁方式，一种是使用`synchronized`关键字，另一种是实现`Lock`接口
- `synchronized`与`Lock`的区别？
  - 打个比方，`synchronized`就像是汽车里的手动挡，我们加锁后就可以不去管它了，并且`synchronized`会自动释放锁，如果你只是想要简单的加个锁，对性能也没什么特别的要求，用`synchronized`关键字就足够了
  - `Lock`接口实现类就像是汽车里的手动挡，当我们想自定义某些条件来影响加锁和释放锁的过程时，就可以尝试实现`Lock`接口
    - 比如说，`Lock`接口的实现类`ReentrantLock`就可以通过结合`Contidion`类来实现有条件的分组唤醒线程；但是`synchronized`只能结合`wait() / notify() / notifyall()`来随机唤醒线程或者全部唤醒线程

### `synchronized`与`ReentrantLock`

- `synchronized`是`JVM`层面实现的，`ReentrantLock`是`JDK1.5`之后引入的
- `synchronized`在`JDK1.6`引入了自旋锁、偏向锁后，性能和`ReentrantLock`差不多，但在引入之前，性能要远低于`ReentrantLock`
- `synchronized`会自动释放锁，`ReentrantLock`不会
- `synchronized`是非公平锁，但`ReentrantLock`可以在公平锁和非公平锁之间切换，默认是非公平锁
- `ReentrantLock`就可以通过结合`Contidion`类来实现有条件的分组唤醒线程；但是`synchronized`只能结合`wait() / notify() / notifyall()`来随机唤醒线程或者全部唤醒线程
- `ReentrantLock`提供了能够中断等待锁的线程的机制，当一个线程一直等待而不能获取琐时，就可以中断等待转而先去执行其他的任务

### `cas`

- `cas`即`Compare-and-
  Swap`，比较并替换，是乐观锁的基石
- `cas`的底层调用了`c++`实现的`native`方法，而这个本地方法利用了`cpu`的指令，从硬件层面上保证了操作的原子性，已达到类似于锁的效果

### 自旋锁与`cas`

- 自旋锁的自旋操作，说白了就是一个`while(true)`无限循环
- `cas`就有类似的无限循环操作，但它并不是一把自旋锁
  - 尽管自旋与`while(true)`的操作是一样的，但还是应该将这两个术语分开。“自旋”这两个字，特指自旋锁的自旋
  - 然而在`JDK`中并没有自旋锁`SpinLock`这个类，那什么才是自旋锁呢？`synchronized`中的轻量级锁就是一种自旋锁

### `synchronized`锁升级：偏向锁 → 轻量级锁 → 重量级锁

- 偏向锁：
  - 第一个线程去竞争一把未被获取的琐时，锁对象首先由无锁状态（锁标志位为`01`，偏向锁标志位为`0`）升级到偏向锁状态（锁标志位为`01`，偏向锁标志位为`1`）
    - 偏向锁假定将来只会有第一个申请锁的线程来使用锁，而不会有任何其他线程来竞争锁
    - 因此，偏向锁会在锁对象的对象头中的`Mark Word`中`cas`记录`owner`指针，将`owner`指针指向持有它的线程，如果记录成功，则偏向锁获取成功，就记录锁状态为偏向锁
    - 以后，当前线程再来获取琐时，只要它等于`owner`中的引用，就可以零成本的直接获取锁；否则，就说明有其他线程竞争，偏向锁会升级成轻量级锁
  - 偏向锁无法使用自旋锁优化，因为一旦有其他线程竞争锁，就破坏了偏向锁的假定
- 轻量级锁：
  - 锁升级到轻量级锁后，会将锁标志位置为`00`
  - 在轻量级锁状态竞争锁时，没有竞争到锁的线程将自旋等待，直到成功获取锁
    - 但是，长时间的自旋操作是非常耗费资源的，一个线程持有锁时，其他线程只能原地空耗`cpu`，不能执行其他的任务，陷入忙等的局面
    - 显然，忙等必须进行限制，可以通过设置自旋次数（默认`10`次，可通过`JVM`的参数更改）来进行限制
    - 如果锁竞争严重，那么某个达到最大自旋次数的线程，就会将轻量级锁升级成重量级锁，那么后续线程再来尝试获取锁时，发现被占用的是一把重量级锁，就会直接将自己挂起，等待将来被唤醒，而不是进行忙等
- 重量级锁
  - 锁升级到轻量级锁后，会将锁标志位置为`11`

### 死锁

- 因系统资源的竞争、进程（线程）运行时推进顺序不当而引起的线程阻塞现象，若无外力干涉，这些线程都无法推进下去
- 死锁产生的四个必要条件：
  - 互斥条件
  - 请求与保持
  - 不可剥夺
  - 循环等待





























