## HTTP

### HTTP

- `HTTP`是一个无状态的应用层协议，它基于`TCP/IP`来传输数据

#### - 报文结构

- 客户端发送一个`HTTP`请求报文给服务器，服务器会根据请求报文中的信息进行处理，并将处理结果放入`HTTP`响应报文中返回给客户端

  - 客户端请求报文结构

    ![image-20210407170849907](..\assets\statics\客户端请求报文结构.png)

  - 服务器响应报文结构

    ![image-20210407171234523](D:\CODE\JAVA\leetcode_algorithm\src\interview\assets\statics\服务器响应报文结构.png)

#### - URL

- `HTTP`使用`URL(Uniform Resource Locator, 统一资源定位符)`来定位资源

- `URL`是`URI(Uniform Resource Identifier, 统一资源标识符)`的子集。`URI`除了包含`URL`，还包含`URN(Uniform Resource Name, 统一资源名称)`。`URN`只是被用来定义一个资源的名称，并不具备定位该资源的能力

  ![image-20210408183648458](..\assets\statics\URI&URL&URN.png)

#### - HTTP方法

- 安全的方法：安全的`HTTP`方法不会改变服务器状态，也就是说它只是可读的
  - `GET: `用于获取资源
  - `HEAD: `用于获取报文首部
  - `OPTIONS: `用于查询当前`URL`支持的方法
- 不安全的方法：不安全的`HTTP`方法会引起服务器的状态改变
  - `POST: `用于传输实体主体
  - `PUT: `用于上传文件
  - `DELETE: `用于删除文件

#### - HTTP状态码：

| 状态码 |                类别                |            含义            |
| :----: | :--------------------------------: | :------------------------: |
|  1xx   |  `Informational`（信息性状态码）   |    表接收的请求正在处理    |
|  2xx   |      `Success`（成功状态码）       |      请求正常处理完毕      |
|  3xx   |   `Redirection`（重定向状态码）    | 需要进行附加操作以完成请求 |
|  4xx   | `Client Error`（客户端错误状态码） |     服务器无法处理请求     |
|  5xx   | `Server Error`（服务器错误状态码） |     服务器处理请求出错     |

- 示例：
  - `100 Continue`：表明到目前为止都很正常，客户端可以继续发送请求或者忽略这个响应
  - `200 OK`
  - `204 No Content`：请求已经成功处理，但是返回的响应报文不包含实体的主体部分。一般在只需要从客户端往服务器发送信息，而不需要返回数据时使用
  - `302 Found`：临时性重定向
  - `400 Bad Request`：请求报文中存在语法错误
  - `403 Forbidden`：请求被拒绝。
  - `404 Not Found`
  - `500 Internal Server Error`：服务器正在执行请求时发生错误
  - `503 Service Unavailable`：服务器暂时处于超负载或正在进行停机维护，现在无法处理请求

#### - 短连接与长连接

- 短连接：每建立一次`HTTP`通信就要新建一个`TCP`连接
- 长连接：只需要建立一次`TCP`连接就能进行多次`HTTP`通信
- 区别：
  - 当浏览器访问一个包含多张图片的`HTML`页面时，除了请求访问的`HTML`页面资源，还会请求图片资源。此时如果采用短连接，那么开销会很大
  - `HTTP/1.1`之前默认是短连接，如果需要使用长连接，则使用`Connection : Keep-Alive`
  - `HTTP/1.1`开始默认是长连接，如果要断开连接，需要由客户端或服务器提出断开，使用`Connection : close`

#### - 流水线

- 默认情况下，`HTTP`请求是按顺序发出的，下一个请求只有在当前请求收到响应之后才会被发出。由于受到网络延迟和带宽的限制，在下一个请求被发送到服务器之前，可能需要等待很长时间
- 流水线是在同一条长连接上连续发出请求，而不用等待响应返回，这样可以减少延迟

#### - HTTP/1.1 新特性

- 默认是长连接
- 支持流水线
- 支持同时打开多个`TCP`连接
- 新增状态码`100 Continue`
- 支持分块传输编码，支持虚拟主机，新增缓存处理指令`max-age`

### HTTPS

- `HTTPS`并不是新协议，而是让`HTTP`先和`SSL（Secure Sockets Layer）`通信，再由`SSL`和`TCP`通信
- 通过使用`SSL`，`HTTPS`具有了加密（防窃听）、认证（防伪装）和完整性保护（防篡改）：
  - 加密：
    - 对称加密：加密和解密使用同一密钥
      - 优点：运算速度快
      - 缺点：无法安全的将密钥传输给通信方
    - 非对称加密：加密和解密使用不同的密钥
      - 公开密钥所有人都可以获得，通信发送方获得接收方的公开密钥之后，就可以使用公开密钥进行加密，接收方收到通信内容后使用私有密钥解密
      - 优点：可以更安全地将公开密钥传输给通信发送方
      - 缺点：运算速度慢
    - `HTTPS`采用了混合的加密机制：先使用非对称加密方式，传输对称加密方式所需要的`Secret Key`，从而保证安全性；获取`Secret Key`后，再使用对称加密方式进行通信，从而保证效率
  - 认证：通过使用证书来对通信方进行认证
    - 数字证书认证机构（`CA, Certificate Authority`）：是客户端和服务器双方都可信赖的第三方机构
      - 服务器的运营人员向`CA`提出公开密钥的申请，`CA`在判明提出申请者的身份之后，会对已申请的公开密钥做数字签名，然后分配这个已签名的公开密钥，并将该公开密钥放入公开密钥证书后绑定在一起
    - 进行`HTTPS`通信时，服务器会把证书发送给客户端。客户端取得其中的公开密钥之后，先使用数字签名进行验证，如果验证通过，就可以开始通信了
  - 完整性保护：`SSL`提供报文摘要功能来进行完整性保护
    - `HTTP`也提供了`MD5`报文摘要功能，但不是安全的。例如报文内容被篡改之后，同时重新计算`MD5`的值，通信接收方无法意识到发生了篡改
    - `HTTPS`的报文摘要功能之所以安全，是因为它结合了加密和认证这两个操作。试想一下，加密之后的报文，遭到篡改之后，也很难重新计算报文摘要，因为无法轻易获取明文
- 缺点：
  - 因为需要进行加密解密等过程，因此速度会更慢
  - 需要支付证书授权的高额费用

### Cookie & Session

- `HTTP`协议是无状态的，这种设计主要是为了让`HTTP`协议尽可能的简单，使得它能够处理大量事务


#### - Cookie

- 在`HTTP/1.1`中，引入了`Cookie`来保存状态信息

- `Cookie`是服务器发送到浏览器并保存到浏览器本地的一小块数据，它会在浏览器之后向同一服务器再次发起请求时被携带上，用于告知服务器两个请求是否来自同一个浏览器

- 由于当前浏览器在首次请求之后的每次请求都会携带`Cookie`，因此会带来额外的性能开销

- 用途：

  - 会话状态管理：如用户登录状态、购物车状态等需要记录的信息
  - 个性化设置：如用户自定义设置、主题设置等
  - 浏览器行为跟踪：用于跟踪分析用户行为

- 创建过程：

  - 服务器发送的响应报文包含`Set-Cookie`首部字段，客户端得到响应报文后把`Cookie`内容保存到浏览器本地

    ```http
    // 响应字段
    HTTP/1.0 200 OK
    Content-type: text/html
    Set-Cookie: yummy_cookie=choco
    Set-Cookie: tasty_cookie=strawberry
    
    [page content]
    ```
    
  - 客户端之后对同一个服务器发送请求时，会从浏览器中取出`Cookie`信息，并使请求首部字段携带上`Cookie`，再发送给服务器
    
      ```http
      // 请求字段
      GET /sample_page.html HTTP/1.1
      Host: www.example.org
      Cookie: yummy_cookie=choco; tasty_cookie=strawberry
      ```

#### - Session

- 除了可以将用户信息通过`Cookie`存储在用户浏览器中，也可以利用`Session`存储在服务器端。因此，`Session`更加安全
- `Session`可以存储在服务器上的文件、数据库或者内存中，也可以将`Session`存储在`Redis`这种内存型数据库中，效率会更高
- 使用`Session`维护用户登录状态的过程如下：
  - 用户进行登录时，把用户提交的包含用户名和密码的表单，放入`HTTP`请求报文中
  - 服务器验证该用户名和密码，如果正确则把用户信息存储到`Redis`中，它在`Redis`中的`key`称为`Session ID`
  - 服务器返回的响应报文中的`Set-Cookie`首部字段包含了这个`Session ID`，客户端收到响应报文后将该`Cookie`值存入浏览器中
  - 客户端之后对同一个服务器进行请求时会携带该`Cookie`值，服务器收到请求后会在`Cookie`中提取出`Session ID`，再使用`Session ID`去`Redis`中取出用户信息，继续之前的业务操作
- 当浏览器禁用了`Cookie`时，就只能使用`Session`了。这时也不能再将`Session ID`存放到`Cookie`中，而是要使用`URL`重写技术，将`Session ID`作为`URL`的参数进行传递
- `Session`的默认过期时间为`30`分钟

#### - 区别

- `Cookie`只能存储`ASCII`码字符串，而`Session`可以存储任何类型的数据，因此在考虑数据复杂性时首选`Session`
- `Cookie`存储在浏览器中，容易被恶意查看。如果非要将一些隐私数据存在`Cookie`中，可以将`Cookie`值进行加密，然后在服务器进行解密
- 对于大型网站来说，如果将用户的所有信息都存储在`Session`中，那么服务器的压力是非常大的，因此不建议将所有的用户信息都存储在`Session`中。我们可以只存储一些私密的用户信息，如密码、银行卡号等，而将不那么私密的信息都存在浏览器本地的`Cookie`中来减少服务器的压力

### GET & POST

- 作用：`GET`用于获取资源，`POST`用于传输实体主体

- 参数：

  - `GET`和`POST`的请求都能使用额外的参数，但是`GET`的参数是以查询字符串的形式出现在`URL`中的，而`POST`的参数存储在实体主体中

  - 不能因为`POST`参数存储在实体主体中就认为它的安全性更高，因为照样可以通过一些抓包工具（如`Fiddler`）查看

  - 因为`URL`只支持`ASCII`码，因此`GET`的参数中如果存在中文等字符就需要先进行编码，而`POST`的参数支持标准字符集

  - 示例：

    ```http
    GET /test/demo_form.asp?name1=value1&name2=value2 HTTP/1.1
    ```

    ```http
    POST /test/demo_form.asp HTTP/1.1
    Host: w3schools.com
    name1=value1&name2=value2
    ```

- 安全：安全的`HTTP`方法不会改变服务器状态，也就是说它只是可读的。`GET`方法是安全的，`POST`不是

- 幂等性：

  - 幂等的`HTTP`方法，同样的请求被执行一次与连续执行多次的效果是一样的，服务器的状态也是一样的，也就是说幂等方法不应该具有副作用

  - 所有的安全方法都是幂等的

  - 某些非安全方法在正确的实现下也是幂等的，如`PUT`、`DELETE`，比如下面的方法，多次调用只有状态码不一样

    ```http
    DELETE /idX/delete HTTP/1.1   -> Returns 200 if idX exists
    DELETE /idX/delete HTTP/1.1   -> Returns 404 as it just got deleted
    DELETE /idX/delete HTTP/1.1   -> Returns 404
    ```

  - `POST`不是幂等方法，比如下面的方法，多次调用会增加多行记录

    ```http
    POST /add_row HTTP/1.1   -> Adds a 1nd row
    POST /add_row HTTP/1.1   -> Adds a 2nd row
    POST /add_row HTTP/1.1   -> Adds a 3rd row
    ```

- ` XMLHttpRequest:`

  - ` XMLHttpRequest`是一个`API`，它为客户端提供了在客户端和服务器之间传输数据的功能。它提供了一个通过`URL `来获取数据的简单方式，并且不会使整个页面刷新。这使得网页只更新一部分页面而不会打扰到用户。` XMLHttpRequest`在`AJAX`中被大量使用
  - 在使用` XMLHttpRequest`的`POST`方法时，浏览器会先发送`Header`再发送`Data`。但并不是所有浏览器会这么做，例如火狐就不会
  - 在使用` XMLHttpRequest`的`GET`方法时，`Header`和`Data`会一起发送

## JWT

- `JWT`全称`Json Web Token`
- `token`是按照一定规则生成的字符串，但是规则是自定义的，而`JWT`是一种通用的规则
- `encode`：比如`asjri4bc82hr.sa1b2dfekjYe9D.qm34rp76it`，由两个`.`划分成了三个部分
  - 第一部分：`JWT`头信息，是一个描述`JWT`元数据的`JSON`对象
  - 第二部分：有效载荷，包含了主体信息（用户信息）
  - 第三部分：签名哈希，对上面两部分数据签名，确保数据不会被更改

## 单点登录

- 三种实现方式：
  - `session`广播：也就是`session`复制，将一个微服务模块上已存储登录信息的`session`复制到所有其他分布式模块中，缺点是在集群模块很多时，复制过程将消耗极大的资源
  - `cookie + redis`：
    1. 在集群的任一模块中进行登录，之后，将数据放到两个地方：
       1. `redis`：`key`中存入随机生成的唯一值，`value`中存入用户数据，可以通过设置`redis`的过期时间来做到和`session`一样的效果
       2. `cookie`：把`redis`中生成的`key`存入`cookie`
    2. 访问集群中其他模块时，浏览器发送的请求会携带`cookie`信息
    3. 服务器得到请求后，会获取`cookie`值，并把`cookie`中获取到的值拿到`redis`中进行查询，通过是否能够查询到数据判断当前是否是登录
  - `token`：
    1. 在集群的任一模块中进行登录，登录后，按照规则生成字符串，再将登录后的用户信息包含到字符串中，进行一些编码加密的工作
    2. 将字符串返回（通过`cookie`或通过地址栏）
    3. 再去访问其他模块时，每次访问都会在地址栏带上生成的字符串，在访问模块中获取地址栏中的字符串，将字符串解码获取里面的用户信息
       - 通过是否能在字符串中获取到用户信息判断当前是否是登录

## RPC 与 HTTP

- 远程调用：无论是微服务还是分布式服务，都是`SOA, Service-Oriented Architecture`，都是面向服务编程，都面临着服务间的远程调用
- `RPC, Remote Produce Call`：远程过程调用
  - 使用自定义数据格式，基于原生`TCP`通信，速度快，效率高
- `RPC`与`HTTP`的异同：
  - 相同点：
    - 都是远程调用方式，都可以实现服务调用服务
    - 都基于`TCP`通信，底层通信都基于`Socket`
  - 不同点：
    - `RPC`可以自定义数据格式；`HTTP`的数据传输格式是有规定的
    - `RPC`要求服务提供方和服务调用方都需要使用相同的技术；`HTTP`无需关注语言的实现，只需要遵循`restful`规范




