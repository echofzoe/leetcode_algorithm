# JVM 内存区域

## 1. 内存区域划分

- 在`JVM`中，内存区域可大致**划分**为下图结构

  <img src="..\assets\statics\JVM内存区域\JVM内存区域划分.png" alt="JVM内存区域划分" style="zoom:55%;" />
  
- 在`JVM`中，内存区域可大致**分类**为下图结构

  <img src="..\assets\statics\JVM内存区域\JVM内存区域分类.png" alt="JVM内存区域划分" style="zoom:75%;" />

- **线程私有**区域的生命周期与线程相同，依赖用户线程的 启动/结束 而 创建/销毁 （在`Hotspot VM `内，每个线程都与操作系统的本地线程直接映射, 因此这部分内存区域的 存在/销毁 与本地线程的 生/死 对应）
- **线程共享**区域随虚拟机的 启动/关闭 而 创建/销毁
- **直接内存**并不是`JVM`运行时数据区的一部分，但也会被频繁的使用
  - 在`JDK 1.4`引入的`NIO`中提供了基于`Channel`与`Buffer`的`IO`方式，它可以使用`Native`函数库直接分配堆外内存，然后使用`DirectByteBuffer`对象作为这块内存的引用进行操作，这样就避免了在`Java`堆和`Native`堆中来回复制数据，因此在一些场景中可以显著提高性能

## 2. 各内存区域

### 2.1 线程私有

#### 2.1.1 程序计数器

- 一块较小的内存空间，是**当前线程所执行的字节码的行号指示器**，每条线程都要有一个独立的程序计数器
  - 正在执行`Java`方法时，计数器记录的是虚拟机字节码指令的地址（当前指令的地址），如果正在执行的`Native`方法，则为空
  - **这个内存区域是唯一一个在`JVM`中没有规定任何`OutOfMemoryError`情况的区域**

#### 2.1.2 虚拟机栈

- 是描述`Java`方法执行的内存模型
  - 每个方法在执行的同时都会创建一个栈帧
  - 每一个方法从调用到执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程
- 栈帧，`Stack Frame`，用于存储局部变量表、操作数栈、动态链接、方法出口等信息
  - 栈帧是用来存储数据和部分过程结果的数据结构
  - 栈帧也被用来处理动态链接`(Dynamic Linking)`、 方法返回值和异常分派`(Dispatch Exception)`
  - 栈帧随着方法调用而创建，随着方法结束而销毁，无论方法是正常完成还是异常完成（抛出了在方法内未被捕获的异常）都算作方法结束

#### 2.1.3 本地方法栈

- 本地方法栈和虚拟机栈作用类似，区别是虚拟机栈为执行`Java`方法服务，而本地方法栈则为`Native`方法服务，如果一个`VM`实现使用`C-linkage`模型来支持`Native`调用，那么该栈将会是一个`C`栈，但`HotSpot VM`直接就把本地方法栈和虚拟机栈合二为一

### 2.2 线程共享

#### 2.2.1 堆 - 运行时数据区

- 是被线程共享的一块内存区域，创建的对象和数组都保存在`Java`堆内存中，也是垃圾收集器进行垃圾收集的最重要的内存区域
- 由于现代`VM`普遍采用分代收集算法，因此`Java`堆从`GC`的角度还可以细分为：
  - 新生代（`Eden`区、`From Survivor`区和`To Survivor`区）
  - 老年代

#### 2.2.2 方法区

- **在`JVM`规范中，方法区是线程共享的运行时内存区域，是堆的逻辑组成部分**
  - 虽然方法区是堆的逻辑组成部分，但是虚拟机可以选择不在方法区实现`GC`，因为这样做效率很低：
    - ***方法区的`GC`主要是针对废弃常量和无用的类：***
      - 废弃常量的回收与回收堆中的对象非常类似，如果一个字符串`"aaa"`已经进入了常量池中，但是当前没有任何一个`String`叫做`"aaa"`的，也没有其他地方引用了这个字面量，如果在这个时候发生`GC`，而且必要的话，就会将常量`"aaa"`移除常量池，常量池中的其他类、接口、方法、字段的符号引用也与此类似
      - 判定一个常量是否是`废弃常量`比较简单，而要判定一个类是否是`无用的类`的条件则相对苛刻许多。类需要同时满足下面`3`个条件才能算是`无用的类`：
        - 该类所有的实例都已经被回收，也就是`Java`堆中不存在该类的任何实例
        - 加载该类的`ClassLoader`已经被回收
        - 该类对应的`java.lang.Class`对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法
  - 不同的`JVM`厂商，对于方法区有着不同的实现方式：
    - `HotSpot`将虚拟机堆内存划分为新生代和老年代，对堆内存进行分代管理，将堆的另一块空间划分成为永久代，用作方法区，这样`HotSpot`的垃圾收集器就可以像管理`Java`堆一样管理这部分内存，而不必为方法区开发专门的内存管理器
  - **在不同的`JDK`版本中，方法区中存储的数据是不一样的：**
    - ***在`JDK1.6`及以前，运行时常量池是方法区的一部分***，方法区中还存储了类的元信息、静态变量、JIT 编译后的代码（比如`Spring`使用`IOC`或`AOP`创建的`Bean`，或者以`cglib`、反射等形式动态生成的`class`信息）等
      - `Class`文件中除了有类的版本、字段、方法、接口等描述等信息外，还有一项信息是常量池`(Constant Pool Table)`，用于存放编译期生成的各种字面量和符号引用，***这部分内容将在类加载后存放到方法区的运行时常量池中***
      - `Java`虚拟机对`Class`文件的每一部分（自然也包括常量池）的格式都有严格的规定，每一个字节用于存储哪种数据都必须符合规范上的要求，这样才会被虚拟机认可、装载和执行
    - ***在`JDK1.7`，`JVM`将运行时常量池从方法区中移了出来，在堆中开辟了一块内存存放常量池及静态变量***
    - ***在`JDK1.8`，`JVM`删除了永久代，引入了元空间***

##### 2.2.2.1 方法区实现版本更迭

- `JDK1.6`及之前方法区的实现就是永久代
- `JDK1.7`把常量池和静态变量放入了堆中，也就是说方法区由永久代（类信息）和堆（常量池、静态变量）实现
- `JDK1.8`删除了永久代，引入了元空间，也就是说方法区由元空间（类信息）和堆（常量池、静态变量）实现

##### 2.2.2.2 元空间

- 元空间并不是方法区，方法区包括类的元信息、常量池、类变量（静态变量）、静态方法的引用等
- `HotSpot`虚拟机在`JDK1.8`后已经取消了永久代，改为元空间，类的元信息被存储在元空间中
- 元空间没有使用堆内存，而是转而使用与堆不相连的本地内存区域。所以，理论上系统可以使用的内存有多大，元空间就有多大，所以不会出现永久代存在时的内存溢出问题
  - 这项改造也是有必要的，永久代的调优是很困难的，虽然可以设置永久代的大小，但是很难确定一个合适的大小，因为其中的影响因素很多，比如类数量的多少、常量数量的多少等
  - 永久代中的元数据的位置也会随着一次`Full GC`发生移动，比较消耗虚拟机性能。同时，`HotSpot`虚拟机的每种类型的垃圾回收器都需要特殊处理永久代中的元数据。将元数据从永久代剥离出来，不仅实现了对元空间的无缝管理，还可以简化`Full GC`以及对以后的并发隔离类元数据等方面进行优化

##### 2.2.2.3 永久代

- 方法区和永久代的关系很像 Java 中接口和类的关系，类实现了接口，而永久代就是`HotSpot`虚拟机对虚拟机规范中方法区的一种实现方式：
  - `JDK1.8`之前的`HotSpot`中，堆 = 年轻代 + 老年代，逻辑上不包括永久代（方法区），但物理上包括

## 3. 特殊补充

### 3.1 新生代

- **用来存放新生的对象**，一般占据堆的`1/3`空间
- 由于频繁创建对象，所以新生代会频繁触发`MinorGC`进行垃圾回收

#### 3.1.1 内存分区

- 新生代又分为`Eden`区、`From Survivor`区和`To Survivor`区，占比`8:1:1`
  - `Eden`区
    - `Java`新对象的出生地（如果新创建的对象占用内存很大，则直接分配到老年代）。当`Eden`区内存不够的时候就会触发`MinorGC`，对新生代内存区域进行一次垃圾回收
  - `From Survivor`区
    - 上一次`GC`的幸存者，作为这一次`GC`的被扫描者
  - `To Survivor`区
    - 保留了一次`MinorGC`过程中的幸存者

#### 3.1.2 MinorGC

- `MinorGC`采用复制算法：
  - 首先把`Eden, From Survivor`区域中存活的对象复制到`To Survivor`区（如果有对象的年龄已经达到了老年代的标准，则直接放入老年代；如果`To Survivor`放不下了，也直接放入老年代），同时把这些对象的年龄`+1`
  - 接着直接清空`Eden, From Survivor`区中的对象
  - 最后将`From Survivor`和`To Survivor`区域中的对象互换，则原`To Survivor`区域中的对象就构成了下一次`GC`时的`From Survivor`区

### 3.2 老年代

- **主要存放应用程序中生命周期长的内存对象**
- 老年代的对象比较稳定，所以`MajorGC`不会频繁执行，且在进行`MajorGC`前一般都已经进行过一次`MinorGC`，使得有新生代的对象晋身入老年代，导致空间不够用时才触发。当无法找到足
  够大的连续空间分配给新创建的较大对象时也会提前触发一次 MajorGC 进行垃圾回收腾出空间。

#### 3.2.1 MajorGC

- 当`MinorGC`后，从新生代新进入老年代的对象导致老年代的空间不足时，会触发一次`MajorGC`
- 当新生代中无法找到足够大的连续空间分配给较大对象时，会触发一次`MajorGC`
- `MajorGC`采用标记清除算法：
  - 首先扫描一次所有的老年代对象，标记出存活的对象；然后直接回收所有没有标记的对象
- `MajorGC`耗时较长，并且会产生内存碎片

### 3.3 JVM 的三种常量池

- 字符串常量池（也叫全局字符串池、`String Pool`、`String Literal Pool`）
  - 在`HotSpot`里实现的`String Pool`是一个`StringTable`类，它是一个`Hash`表，默认值长度是`1009`
  - 这个`StringTable`在每个`HotSpot VM`的实例只有一份，被所有的类共享
  - 字符串常量由一个一个字符组成，放在了`StringTable`上
  - 在`JDK1.6`中，`StringTable`的长度是固定的，长度就是`1009`，因此如果放入`String Pool`中的`String`非常多，就会造成`Hash`冲突，导致链表过长，当调用`String.intern()`时会需要到链表上一个一个找，从而导致性能大幅度下降
  - 在`JDK1.7`中，`StringTable`的长度可以通过参数指定`-XX:StringTableSize=66666`
- `class`文件常量池（`Class Constant Pool`）
  - 每个编译后的`class`文件都有一个`class`常量池，`class`文件中除了包含类的接口、方法、字段等描述信息外，还包含着 "常量池"，用于存放编译器生成的各种字面量和符号引用
    - 这里的字面量就是常量的概念，如文本字符串、被声明成`final`的常量值等
- 运行时常量池（`Runtime Constant Pool`）
  - `JVM`在执行某个类的时候，必须经过加载、链接、初始化，而链接又包括验证、准备、解析三个阶段
  - 当类加载到内存中后，`JVM`就会将`class`常量池中的内容存放到运行时常量池中，由此可知，运行时常量池也是每个类都有一个
  - 我的理解是常量池是存在于编译好的字节码文件里的，是静态的。而运行时常量池是在运行时，加载类后，将字节码的静态内容加载到内存，并在需要的时候解析
  - 在解析阶段，会把符号引用替换为直接引用，解析的过程会去查询字符串常量池的`StringTable`，以保证运行时常量池所引用的字符串与字符串常量池中是一致的

